<Project>
  <PropertyGroup>
    <FSharpShimsEnabled Condition="'$(FSharpShimsEnabled)'==''">true</FSharpShimsEnabled>
    <FSharpShimsOutDir Condition="'$(FSharpShimsOutDir)'==''">$(MSBuildProjectDirectory)\Scripts\Generated</FSharpShimsOutDir>
    <!-- Place stamp under obj to avoid polluting Scripts/Generated -->
    <ShimGenStamp>$(IntermediateOutputPath)ShimGen\_shimgen.stamp</ShimGenStamp>
  </PropertyGroup>

  <!-- Godot.NET.Sdk customizes the build pipeline; explicitly wire generation into Build -->
  <PropertyGroup Condition="'$(FSharpShimsEnabled)'=='true'">
    <BuildDependsOn>GenerateFSharpShims;$(BuildDependsOn)</BuildDependsOn>
  </PropertyGroup>

  <!-- Note: We don't include shims at evaluation time to avoid duplicate Compile items.
       We'll add them after generation within the target so they compile in the same build. -->

  <Target Name="GenerateFSharpShims"
    BeforeTargets="CoreCompile;Build"
    DependsOnTargets="ResolveProjectReferences;ResolveReferences"
    Condition="'$(FSharpShimsEnabled)'=='true'">
    <Message Importance="High" Text="[shimgen] GenerateFSharpShims: Project=$(MSBuildProjectFullPath) OutDir=$(FSharpShimsOutDir) ShimGenDll=$(ShimGenDll)" />

    <ItemGroup>
      <!-- Find referenced F# projects via extension filtering -->
      <_FsProjRefs Include="@(ProjectReferenceWithTargetPath)"
                   Condition="$([System.String]::Equals($([System.IO.Path]::GetExtension('%(ProjectReferenceWithTargetPath.OriginalItemSpec)')).ToLowerInvariant(), '.fsproj'))" />
      <!-- Fallback: some SDKs may not populate OriginalItemSpec as expected; also check Identity extension -->
      <_FsProjRefs Include="@(ProjectReferenceWithTargetPath)"
                   Condition="$([System.String]::Equals($([System.IO.Path]::GetExtension('%(ProjectReferenceWithTargetPath.Identity)')).ToLowerInvariant(), '.fsproj'))" />
      <!-- Also capture bare ProjectReference items pointing to F# projects -->
      <_FsProjects Include="@(ProjectReference)"
                   Condition="$([System.String]::Equals($([System.IO.Path]::GetExtension('%(ProjectReference.Identity)')).ToLowerInvariant(), '.fsproj'))" />
    </ItemGroup>
    <!-- Fallbacks: look for F# projects in a sibling 'FSharp' folder or parent tree when ProjectReference metadata is missing -->
    <ItemGroup Condition=" '@(_FsProjects)' == '' ">
      <_FsProjects Include="$(MSBuildProjectDirectory)\..\FSharp\*.fsproj" />
    </ItemGroup>
    <ItemGroup Condition=" '@(_FsProjects)' == '' ">
      <_FsProjects Include="$(MSBuildProjectDirectory)\..\*.fsproj" />
    </ItemGroup>
  <Message Importance="High" Text="[shimgen] discovered F# projects: @(_FsProjects->'%(Identity)', ', ')" />

    <!-- If ProjectReferenceWithTargetPath wasn't populated by ResolveReferences, resolve target paths ourselves. -->
    <MSBuild Projects="@(_FsProjects)"
             Targets="Build;GetTargetPath"
             Properties="DesignTimeBuild=false;Configuration=$(Configuration)"
             BuildInParallel="true">
      <Output TaskParameter="TargetOutputs" ItemName="_FsProjOutputs" />
    </MSBuild>
    <Message Importance="High" Text="[shimgen] resolved outputs: @(_FsProjOutputs->'%(Identity) from %(MSBuildSourceProjectFile)', ', ')" Condition=" '@(_FsProjOutputs)' != '' " />

    <PropertyGroup>
      <ShimOutDir>$(FSharpShimsOutDir)</ShimOutDir>
      <!-- Prefer externally provided path (e.g., local dev override). If unset, try to resolve from NuGet cache, then fall back to local bin/ (when using a repo import), then lib/ path (when imported from a nupkg). -->
      <!-- Discover NuGet packages folder cross-platform: NUGET_PACKAGES env, then NuGetPackageRoot, then HOME/USERPROFILE -->
      <_NuGetPackagesFolder>$([System.Environment]::GetEnvironmentVariable('NUGET_PACKAGES'))</_NuGetPackagesFolder>
      <_NuGetPackagesFolder Condition="'$(_NuGetPackagesFolder)' == '' and '$(NuGetPackageRoot)' != ''">$(NuGetPackageRoot)</_NuGetPackagesFolder>
      <_HomeDir>$([System.Environment]::GetEnvironmentVariable('HOME'))</_HomeDir>
      <_UserProfileDir>$([System.Environment]::GetEnvironmentVariable('USERPROFILE'))</_UserProfileDir>
      <_HomeDir Condition="'$(_HomeDir)' == ''">$(_UserProfileDir)</_HomeDir>
      <_NuGetPackagesFolder Condition="'$(_NuGetPackagesFolder)' == '' and '$(_HomeDir)' != ''">$([System.IO.Path]::Combine('$(_HomeDir)', '.nuget', 'packages'))</_NuGetPackagesFolder>
    </PropertyGroup>
    <ItemGroup>
      <!-- Try to locate the generator inside the NuGet global cache if this project consumes the package -->
      <_ShimGenDllFromNuGet Include="$([System.IO.Path]::Combine('$(_NuGetPackagesFolder)', 'headsetsniper.godot.fsharp.shimgen', '**', 'lib', '$(TargetFramework)', 'Headsetsniper.Godot.FSharp.ShimGen.dll'))" />
    </ItemGroup>
    <PropertyGroup>
      <!-- If found in NuGet cache, use that -->
      <ShimGenDll Condition="'$(ShimGenDll)' == '' and '@(_ShimGenDllFromNuGet)' != ''">@(_ShimGenDllFromNuGet->'%(FullPath)')</ShimGenDll>
      <!-- Fallback: when this targets file is imported from the repo (local dev), prefer the built DLL in bin/{Configuration}/{TFM} -->
      <_ShimGenLocalBinDll>$([System.IO.Path]::Combine('$(MSBuildThisFileDirectory)', '..', 'bin', '$(Configuration)', '$(TargetFramework)', 'Headsetsniper.Godot.FSharp.ShimGen.dll'))</_ShimGenLocalBinDll>
      <ShimGenDll Condition="'$(ShimGenDll)' == '' and Exists('$(_ShimGenLocalBinDll)')">$(_ShimGenLocalBinDll)</ShimGenDll>
      <!-- Final fallback: relative to this targets file location when consumed from a packed nupkg (lib/{TFM}/...) -->
      <_ShimGenLibDll>$([System.IO.Path]::Combine('$(MSBuildThisFileDirectory)', '..', 'lib', '$(TargetFramework)', 'Headsetsniper.Godot.FSharp.ShimGen.dll'))</_ShimGenLibDll>
      <ShimGenDll Condition="'$(ShimGenDll)' == ''">$(_ShimGenLibDll)</ShimGenDll>
    </PropertyGroup>

    <MakeDir Directories="$(ShimOutDir);$([System.IO.Path]::GetDirectoryName('$(ShimGenStamp)'))" />

    <!-- Execute ShimGen once per referenced F# project -->
    <Message Importance="Normal" Text="[shimgen] scanning via ProjectReferenceWithTargetPath: @(_FsProjRefs->'%(OriginalItemSpec) | %(_FsProjRefs.Identity) | %(_FsProjRefs.TargetPath)', ', ')" />
  <Message Importance="Normal" Text="[shimgen] scanning via MSBuild GetTargetPath: @(_FsProjOutputs->'%(Identity) from %(MSBuildSourceProjectFile)', ', ')" />
    <!-- Primary path: Use ProjectReferenceWithTargetPath when available -->
    <Exec Command="dotnet &quot;$(ShimGenDll)&quot; &quot;%(_FsProjRefs.TargetPath)&quot; &quot;$(ShimOutDir)&quot; &quot;$([System.IO.Path]::GetDirectoryName('%(_FsProjRefs.OriginalItemSpec)'))&quot;"
      StandardOutputImportance="Low"
      StandardErrorImportance="High"
      Condition=" '@(_FsProjRefs)' != '' " />
    <!-- Fallback path: Use resolved target paths and compute fsproj dir from corresponding _FsProjects item -->
    <Exec Command="dotnet &quot;$(ShimGenDll)&quot; &quot;%(_FsProjOutputs.Identity)&quot; &quot;$(ShimOutDir)&quot; &quot;$([System.IO.Path]::GetDirectoryName('%(_FsProjOutputs.MSBuildSourceProjectFile)'))&quot;"
      StandardOutputImportance="Low"
      StandardErrorImportance="High"
      Condition=" '@(_FsProjRefs)' == '' and '@(_FsProjOutputs)' != '' " />
    <Message Importance="High" Condition=" '@(_FsProjRefs)' == '' and '@(_FsProjOutputs)' == '' " Text="[shimgen] no F# ProjectReference items with resolvable TargetPath found; skipping generation" />

    <!-- Write a stamp for troubleshooting (not used for skip logic anymore) -->
    <PropertyGroup>
      <_ShimgenStampContent>[stamp] Project=$(MSBuildProjectFullPath) ShimGen=$(ShimGenDll)</_ShimgenStampContent>
    </PropertyGroup>
    <WriteLinesToFile File="$(ShimGenStamp)"
            Lines="$(_ShimgenStampContent)"
            Overwrite="true"
            Condition=" '@(_FsProjRefs)' != '' or '@(_FsProjOutputs)' != '' " />

    <!-- Ensure generated files are part of Compile in this very build -->
    <ItemGroup Condition=" '@(_FsProjRefs)' != '' or '@(_FsProjOutputs)' != '' ">
      <Compile Include="$(FSharpShimsOutDir)\**\*.cs" />
    </ItemGroup>

    <!-- Back-compat cleanup: remove any legacy stamp that might have been written in Scripts/Generated -->
    <ItemGroup>
      <_LegacyStamp Include="$(ShimOutDir)\_shimgen.stamp" />
    </ItemGroup>
    <Delete Files="@(_LegacyStamp)" ContinueOnError="true" />

    <ItemGroup>
      <_GeneratedCs Include="$(FSharpShimsOutDir)\**\*.cs" />
    </ItemGroup>
    <Message Importance="High" Text="[shimgen] Generated @(_GeneratedCs->'%(RecursiveDir)%(Filename)%(Extension)', ', ')" Condition=" '@(_GeneratedCs)' != '' " />
  </Target>

  <!-- Extra safety: hook into the common BeforeBuild extension point to run generator -->
  <Target Name="BeforeBuild" DependsOnTargets="GenerateFSharpShims" />

  <!-- Note: A previous design-time helper attempted to add References based on computed metadata.
       This caused IDE load errors in VS Code due to metadata usage inside Conditions during design-time evaluation.
       The helper is intentionally removed; ProjectReference should suffice for IDE symbol resolution. -->
</Project>
